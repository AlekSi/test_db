package main

import (
	"database/sql"
	"encoding/binary"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"
	"sync/atomic"
	"time"

	_ "github.com/go-sql-driver/mysql" // register database/sql driver
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"gopkg.in/reform.v1"
	mysqldialect "gopkg.in/reform.v1/dialects/mysql"

	"github.com/AlekSi/test_db/convert/mongodb"
	"github.com/AlekSi/test_db/convert/mysql/sakila"
)

const (
	mysqlURI = "root@/sakila?parseTime=true&clientFoundRows=true&time_zone='UTC'"
	mongoURI = "mongodb://localhost/monila"
)

func main() {
	flag.Parse()

	mysqlSQLDB, err := sql.Open("mysql", mysqlURI)
	if err != nil {
		log.Fatal(err)
	}
	defer mysqlSQLDB.Close()

	mysqlDB := reform.NewDB(mysqlSQLDB, mysqldialect.Dialect, reform.NewPrintfLogger(log.Printf))

	views := []reform.View{
		// mysql.ActorInfoView, // view
		sakila.ActorTable,
		sakila.AddressTable,
		sakila.CategoryTable,
		sakila.CityTable,
		sakila.CountryTable,
		// mysql.CustomerListView, // view
		sakila.CustomerTable,
		sakila.FilmActorView,
		sakila.FilmCategoryView,
		// mysql.FilmListView, // view
		sakila.FilmTable,
		sakila.FilmTextTable,
		sakila.InventoryTable,
		sakila.LanguageTable,
		// mysql.NicerButSlowerFilmListView, // view
		sakila.PaymentTable,
		sakila.RentalTable,
		// mysql.SalesByFilmCategoryView, // view
		// mysql.SalesByStoreView,        // view
		// mysql.StaffListView,           // view
		sakila.StaffTable,
		sakila.StoreTable,
	}

	script := []string{
		"#!/bin/sh\n",
		"# Generated by convert.go. DO NOT EDIT.\n",

		// docker-entrypoint.sh sources the script with the current directory set to /
		"DIR=$(dirname $BASH_SOURCE)\n",
	}

	for _, view := range views {
		importView(mysqlDB, view)
		exportView(view)

		cmd := fmt.Sprintf(
			"mongoimport --uri=%s --collection=%s --drop --maintainInsertionOrder $DIR/%s",
			mongoURI, view.Name(), view.Name()+".json",
		)
		script = append(script, cmd)
	}

	fn := filepath.Join("..", "mongodb", "monila", "import.sh")
	if err := os.WriteFile(fn, []byte(strings.Join(script, "\n")+"\n"), 0o755); err != nil {
		log.Fatal(err)
	}
}

func importView(db *reform.DB, view reform.View) {
	rows, err := db.SelectRows(view, "")
	if err != nil {
		log.Fatal(err)
	}
	defer rows.Close()

	r, w := io.Pipe()
	done := make(chan error)
	go func() {
		done <- mongodb.Import(mongoURI, view.Name(), r)
	}()

	for {
		str := view.NewStruct()
		if err = db.NextRow(str, rows); err != nil {
			break
		}

		var id uint32
		if r, ok := str.(reform.Record); ok {
			switch v := r.PKValue(); v := v.(type) {
			case int8:
				id = uint32(v)
			case int16:
				id = uint32(v)
			case int32:
				id = uint32(v)
			default:
				log.Fatalf("Unhandled PK type %T for %s.", v, str)
			}
		}

		cols := view.Columns()
		d := make(bson.D, 0, len(cols)+1)
		d = append(d, primitive.E{Key: "_id", Value: newObjectID(id)})
		for i, val := range str.Values() {
			d = append(d, primitive.E{Key: cols[i], Value: val})
		}

		b, err := bson.MarshalExtJSON(d, true, true)
		if err != nil {
			log.Fatal(err)
		}

		log.Printf("%s", b)
		w.Write(b)
	}
	if err != reform.ErrNoRows {
		log.Fatal(err)
	}

	if err := w.Close(); err != nil {
		log.Fatal(err)
	}

	err = <-done
	if err != nil {
		log.Fatal(err)
	}
}

func exportView(view reform.View) {
	f, err := os.Create(filepath.Join("..", "mongodb", "monila", view.Name()+".json"))
	if err != nil {
		log.Fatal(err)
	}
	defer func() {
		if err := f.Close(); err != nil {
			log.Fatal(err)
		}
	}()

	if err := mongodb.Export(mongoURI, view.Name(), f); err != nil {
		log.Fatal(err)
	}
}

var (
	ts              = uint32(time.Date(2021, 9, 1, 0, 0, 0, 0, time.UTC).Unix())
	objectIDCounter uint32
)

// newObjectID generates stable BSON ObjectID to make conversion results stable.
func newObjectID(id uint32) primitive.ObjectID {
	processUnique := make([]byte, 5)
	binary.BigEndian.PutUint32(processUnique, id)

	var b [12]byte

	binary.BigEndian.PutUint32(b[0:4], ts)
	copy(b[4:9], processUnique)

	v := atomic.AddUint32(&objectIDCounter, 1)
	b[9] = byte(v >> 16)
	b[10] = byte(v >> 8)
	b[11] = byte(v)

	return b
}
